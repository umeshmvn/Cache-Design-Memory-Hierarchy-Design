# -*- coding: utf-8 -*-
"""sim_cache.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SgBKxYQS0O4IwgNoPLLDM6b2MMP_UPqd
"""

import math, CacheSimulator


try:
    input_list = input().split()
    BLOCKSIZE, L1_SIZE, L1_ASSOC, L2_SIZE, L2_ASSOC, REPLACEMENT_POLICY, INCLUSION_PROPERTY = map(int, input_list[:-1])
    trace_file = input_list[-1]

    inclusive_bit_value = [0]

    # calculations for L1
    SET_SIZE_OF_L1 = (L1_SIZE) // (BLOCKSIZE * L1_ASSOC)
    EXPONENT_SET_SIZE_OF_L1 = int(math.log2(SET_SIZE_OF_L1))
    TAG_LIMIT_OF_L1 = 32 - EXPONENT_SET_SIZE_OF_L1 - int(math.log2(BLOCKSIZE))
    PARAMETERS_OF_L1 = {'L1_reads': 0, 'L1_writes': 0, 'L1_readmiss': 0, 'L1_writemiss': 0, 'L1_hits': 0, 'L1_writebacks': 0}
    L1 = dict(map(lambda i: (i, []), range(SET_SIZE_OF_L1)))
    LRU_L1 = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L1)))
    FIFO_L1 = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L1)))
    L1_dirty_dict = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L1)))



    SET_SIZE_OF_L2 = 0
    EXPONENT_SET_SIZE_OF_L2 = 0
    TAG_LIMIT_OF_L2 = 0
    TAG_INFO_OF_L2 = []

    if L2_SIZE != 0 and L2_ASSOC != 0:
        SET_SIZE_OF_L2 = L2_SIZE // (BLOCKSIZE * L2_ASSOC)
        EXPONENT_SET_SIZE_OF_L2 = int(math.log2(SET_SIZE_OF_L2))
        TAG_LIMIT_OF_L2 = 32 - EXPONENT_SET_SIZE_OF_L2 - int(math.log2(BLOCKSIZE))
        TAG_INFO_OF_L2.extend([SET_SIZE_OF_L2, EXPONENT_SET_SIZE_OF_L2, TAG_LIMIT_OF_L2])

        L2 = dict(map(lambda i: (i, []), range(SET_SIZE_OF_L2)))
        LRU_L2 = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L2)))
        FIFO_L2 = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L2)))
        L2_dirty_dict = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L2)))


    file_info_temp2 = []
    l1_tag_value_list = []

except ValueError as ve:
    print(f"Error in input: {ve}")
    exit()

file_open = open(trace_file)
lines = file_open.readlines()
file_open.close()

i = 0
while i < len(lines):
    file_info_temp2.append(lines[i].strip('\n').split(' '))
    if len(file_info_temp2[i][1]) < 8:
        number_of_zeroes = 8 - len(file_info_temp2[i][1])
        file_info_temp2[i][1] = str(('0' * number_of_zeroes) + str(file_info_temp2[i][1]))
        # binary conversion -> 32
    file_info_temp2[i][1] = bin(int(file_info_temp2[i][1], 16))[2:].zfill(32)
    L1_tag_value = file_info_temp2[i][1][0:TAG_LIMIT_OF_L1 + EXPONENT_SET_SIZE_OF_L1]
    l1_tag_value_list.append(L1_tag_value)
    i += 1



L1_dirty_dict={}
for i in range(SET_SIZE_OF_L1):
    L1_dirty_dict[i]={}

file_info_temp1=[]
def LRU_Counter_L1_Create(L1_set_value):
    try:
        evict_value = float('inf')
        victim_tag = None

        for s, counter in LRU_L1[L1_set_value].items():
            if counter < evict_value:
                evict_value = counter
                victim_tag = s

        return victim_tag

    except Exception as e:
        print(f"An error occurred: {e}")


def FIFO_Counter_L1_create(L1_set_value):
    try:
        min_counter = float('inf')
        victim_tag = None

        for s, counter in FIFO_L1[L1_set_value].items():
            if counter < min_counter:
                min_counter = counter
                victim_tag = s

        return victim_tag

    except Exception as e:
        print(f"An error occurred: {e}")


PARAMETERS_OF_L2={'L2_reads':0,'L2_writes':0,'L2_readmiss':0,'L2_writemiss':0,'L2_hits':0,'L2_writebacks':0}
TAG_INFO_OF_L2=[]


TAG_INFO_OF_L2 = []

if L2_SIZE != 0 and L2_ASSOC != 0:
    SET_SIZE_OF_L2 = (L2_SIZE) // (BLOCKSIZE * L2_ASSOC)
    EXPONENT_SET_SIZE_OF_L2 = int(math.log2(SET_SIZE_OF_L2))
    TAG_LIMIT_OF_L2 = 32 - EXPONENT_SET_SIZE_OF_L2 - int(math.log2(BLOCKSIZE))
    TAG_INFO_OF_L2.extend([SET_SIZE_OF_L2, EXPONENT_SET_SIZE_OF_L2, TAG_LIMIT_OF_L2])


    L2 = dict(map(lambda i: (i, []), range(SET_SIZE_OF_L2)))
    LRU_L2 = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L2)))
    FIFO_L2 = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L2)))
    L2_dirty_dict = dict(map(lambda i: (i, {}), range(SET_SIZE_OF_L2)))


    def LRU_Counter_L2_Create(L2_set_value):
      try:

        victim_tag, _ = min(LRU_L2[L2_set_value].items(), key=lambda item: item[1], default=(None, None))
        return victim_tag

      except Exception as e:
        print(f"An error occurred: {e}")


    def FIFO_Counter_L2_create(L2_set_value):
     try:

        victim_tag, _ = min(FIFO_L2[L2_set_value].items(), key=lambda item: item[1], default=(None, None))
        return victim_tag

     except Exception as e:
        print(f"An error occurred: {e}")

def convert_victim_tag_to_L1_indices(L1_set_index, victim_tag):
    intermediate=[]
    L1_set_index=bin(L1_set_index)[2:]
    if len(L1_set_index)<EXPONENT_SET_SIZE_OF_L1:
        L1_set_index=str(('0'*(EXPONENT_SET_SIZE_OF_L1-len(L1_set_index)))+str(L1_set_index))
    victim_tag=victim_tag + L1_set_index
    L2_tag_value = victim_tag[0:TAG_INFO_OF_L2[2]]
    L2_set_value = int(victim_tag[int(TAG_INFO_OF_L2[2]):int(TAG_INFO_OF_L2[2]+TAG_INFO_OF_L2[1])],2)
    intermediate.append(L2_set_value)
    intermediate.append(L2_tag_value)
    return intermediate


def convert_victim_tag_to_L2_indices(L2_set_index, victim_tag):
    intermediate=[]
    L2_set_index=bin(L2_set_index)[2:]
    if len(L2_set_index)<TAG_INFO_OF_L2[1]:
        L2_set_index=str(('0'*(int(TAG_INFO_OF_L2[1])-len(L2_set_index)))+str(L2_set_index))
    victim_tag=victim_tag + L2_set_index
    L1_tag_value = victim_tag[0:TAG_LIMIT_OF_L1]
    L1_set_value = int(victim_tag[TAG_LIMIT_OF_L1:TAG_LIMIT_OF_L1+EXPONENT_SET_SIZE_OF_L1],2)
    intermediate.append(L1_set_value)
    intermediate.append(L1_tag_value)
    return intermediate


def Handle_L1_Cache_Access(L1_set, L1_tag):
    try:
        index = L1[L1_set].index(L1_tag)
        if L1_dirty_dict[L1_set][L1_tag] == 'D':
            inclusive_bit_value[0] += 1

        L1[L1_set].pop(index)

        if REPLACEMENT_POLICY == 0:
            del LRU_L1[L1_set][L1_tag]
        elif REPLACEMENT_POLICY == 1:
            del FIFO_L1[L1_set][L1_tag]

        del L1_dirty_dict[L1_set][L1_tag]

    except ValueError:
        print(f"Tag {L1_tag} not found in set {L1_set}")

def Handle_L2_Cache_Access(L2_set_value, L2_tag_value, operation):
    try:
        if operation == 'r':
            PARAMETERS_OF_L2['L2_reads'] += 1
            if L2_tag_value in L2[L2_set_value]:
                PARAMETERS_OF_L2['L2_hits'] += 1
                if REPLACEMENT_POLICY == 0:
                    LRU_L2[L2_set_value][L2_tag_value] = max(LRU_L2[L2_set_value].values(), default=0) + 1
            else:
                PARAMETERS_OF_L2['L2_readmiss'] += 1
                handle_L2_miss(L2_set_value, L2_tag_value)
        else:
            PARAMETERS_OF_L2['L2_writes'] += 1
            if L2_tag_value in L2[L2_set_value]:
                PARAMETERS_OF_L2['L2_hits'] += 1
                if REPLACEMENT_POLICY == 0:
                    LRU_L2[L2_set_value][L2_tag_value] = max(LRU_L2[L2_set_value].values(), default=0) + 1
                L2_dirty_dict[L2_set_value][L2_tag_value] = 'D'
            else:
                PARAMETERS_OF_L2['L2_writemiss'] += 1
                handle_L2_miss(L2_set_value, L2_tag_value, is_write=True)

    except Exception as e:
        print(f"An error occurred: {e}")

def handle_L2_miss(L2_set_value, L2_tag_value, is_write=False):
    try:
        if len(L2[L2_set_value]) < L2_ASSOC:
            L2[L2_set_value].append(L2_tag_value)
            if REPLACEMENT_POLICY == 0:
                LRU_L2[L2_set_value][L2_tag_value] = max(LRU_L2[L2_set_value].values(), default=0) + 1
            elif REPLACEMENT_POLICY == 1:
                FIFO_L2[L2_set_value][L2_tag_value] = max(FIFO_L2[L2_set_value].values(), default=0) + 1
            L2_dirty_dict[L2_set_value][L2_tag_value] = 'D' if is_write else 'NA'
        else:
            replace_cache_entry(L2_set_value, L2_tag_value, is_write)

    except Exception as e:
        print(f"An error occurred in handle_L2_miss: {e}")

def replace_cache_entry(L2_set_value, L2_tag_value, is_write):
    try:
        if REPLACEMENT_POLICY == 0:
            new_counter = max(LRU_L2[L2_set_value].values(), default=0) + 1
            victim_tag = LRU_Counter_L2_Create(L2_set_value)
        elif REPLACEMENT_POLICY == 1:
            new_counter = max(FIFO_L2[L2_set_value].values(), default=0) + 1
            victim_tag = FIFO_Counter_L2_create(L2_set_value)

        if INCLUSION_PROPERTY == 1:
            L1_victim_address = convert_victim_tag_to_L2_indices(L2_set_value, victim_tag)
            Handle_L1_Cache_Access(L1_victim_address[0], L1_victim_address[1])

        L2[L2_set_value][L2[L2_set_value].index(victim_tag)] = L2_tag_value
        update_replacement_counters(L2_set_value, L2_tag_value, victim_tag, new_counter, is_write)

    except Exception as e:
        print(f"An error occurred in replace_cache_entry: {e}")

def update_replacement_counters(L2_set_value, L2_tag_value, victim_tag, new_counter, is_write):
    try:
        if REPLACEMENT_POLICY == 0:
            LRU_L2[L2_set_value][L2_tag_value] = new_counter
            del LRU_L2[L2_set_value][victim_tag]
        elif REPLACEMENT_POLICY == 1:
            FIFO_L2[L2_set_value][L2_tag_value] = new_counter
            del FIFO_L2[L2_set_value][victim_tag]

        if L2_dirty_dict[L2_set_value][victim_tag] == 'D':
            PARAMETERS_OF_L2['L2_writebacks'] += 1
        del L2_dirty_dict[L2_set_value][victim_tag]
        L2_dirty_dict[L2_set_value][L2_tag_value] = 'D' if is_write else 'NA'
    except KeyError as e:
        print(f"KeyError: {e}. Unable to perform update_replacement_counters.")

for i in range(len(lines)):
    file_info_temp1.append(lines[i].strip('\n').split(' '))
    if len(file_info_temp1[i][1])<8:
        number_of_zeroes=8-len(file_info_temp1[i][1])
        file_info_temp1[i][1]=str(('0'*number_of_zeroes)+str(file_info_temp1[i][1]))

    file_info_temp1[i][1]=bin(int(file_info_temp1[i][1],16))[2:].zfill(32)
    L1_tag_value = file_info_temp1[i][1][0:TAG_LIMIT_OF_L1]
    if len(file_info_temp1[i][1][TAG_LIMIT_OF_L1:TAG_LIMIT_OF_L1+EXPONENT_SET_SIZE_OF_L1])==0:
        L1_set_value=0
    else:
        L1_set_value = int(file_info_temp1[i][1][TAG_LIMIT_OF_L1:TAG_LIMIT_OF_L1+EXPONENT_SET_SIZE_OF_L1],2)
    if (L2_SIZE !=0 and L2_ASSOC!=0):
        L2_tag_value = file_info_temp1[i][1][0:TAG_LIMIT_OF_L2]
        L2_set_value = int(file_info_temp1[i][1][TAG_LIMIT_OF_L2:TAG_LIMIT_OF_L2+EXPONENT_SET_SIZE_OF_L2],2)

    if file_info_temp1[i][0]=='r':
        PARAMETERS_OF_L1['L1_reads']+=1
        if L1_tag_value in L1[L1_set_value]:
            PARAMETERS_OF_L1['L1_hits']+=1
            if (REPLACEMENT_POLICY==0):
                LRU_L1[L1_set_value][L1_tag_value]=max(LRU_L1[L1_set_value].values())+1
        else:
            PARAMETERS_OF_L1['L1_readmiss']+=1
            if (len(L1[L1_set_value])<L1_ASSOC):
                L1[L1_set_value].append(L1_tag_value)
                if (REPLACEMENT_POLICY==0):
                    if len(LRU_L1[L1_set_value]) != 0:
                        LRU_L1[L1_set_value][L1_tag_value]=max(LRU_L1[L1_set_value].values())+1
                    else:
                        LRU_L1[L1_set_value][L1_tag_value]=0

                elif (REPLACEMENT_POLICY==1):
                    if len(FIFO_L1[L1_set_value]) != 0:
                        FIFO_L1[L1_set_value][L1_tag_value]=max(FIFO_L1[L1_set_value].values())+1
                    else:
                        FIFO_L1[L1_set_value][L1_tag_value]=0
                L1_dirty_dict[L1_set_value][L1_tag_value]='NA'

            else:
                if (REPLACEMENT_POLICY==0):
                    LRU_L1[L1_set_value][L1_tag_value]=max(LRU_L1[L1_set_value].values())+1
                    victim_tag = LRU_Counter_L1_Create(L1_set_value)
                    for i in range(len(L1[L1_set_value])):
                        if L1[L1_set_value][i] == victim_tag:
                            L1[L1_set_value][i] = L1_tag_value
                            break
                    del LRU_L1[L1_set_value][victim_tag]
                    if L1_dirty_dict[L1_set_value][victim_tag]=='D':
                        PARAMETERS_OF_L1['L1_writebacks']+=1
                        if (L2_SIZE!=0 and L2_ASSOC!=0):
                            L2_victim_address = convert_victim_tag_to_L1_indices(L1_set_value, victim_tag)
                            Handle_L2_Cache_Access(L2_victim_address[0], L2_victim_address[1],'w')

                    L1_dirty_dict[L1_set_value][L1_tag_value]='NA'
                    del L1_dirty_dict[L1_set_value][victim_tag]

                if (REPLACEMENT_POLICY==1):
                    FIFO_L1[L1_set_value][L1_tag_value]=max(FIFO_L1[L1_set_value].values())+1
                    victim_tag = FIFO_Counter_L1_create(L1_set_value)
                    for i in range(len(L1[L1_set_value])):
                        if L1[L1_set_value][i] == victim_tag:
                            L1[L1_set_value][i] = L1_tag_value
                            break
                    del FIFO_L1[L1_set_value][victim_tag]
                    if L1_dirty_dict[L1_set_value][victim_tag]=='D':
                        PARAMETERS_OF_L1['L1_writebacks']+=1
                        if (L2_SIZE!=0 and L2_ASSOC!=0):
                            L2_victim_address = convert_victim_tag_to_L1_indices(L1_set_value, victim_tag)
                            Handle_L2_Cache_Access(L2_victim_address[0], L2_victim_address[1],'w')
                    L1_dirty_dict[L1_set_value][L1_tag_value]='NA'
                    del L1_dirty_dict[L1_set_value][victim_tag]
            if not (L2_SIZE == 0 or L2_ASSOC == 0):
              Handle_L2_Cache_Access(L2_set_value, L2_tag_value, 'r')


    else:
        PARAMETERS_OF_L1['L1_writes']+=1
        if L1_tag_value in L1[L1_set_value]:
            PARAMETERS_OF_L1['L1_hits']+=1
            if (REPLACEMENT_POLICY==0):
                LRU_L1[L1_set_value][L1_tag_value]=max(LRU_L1[L1_set_value].values())+1
            L1_dirty_dict[L1_set_value][L1_tag_value]='D'
        else:
            PARAMETERS_OF_L1['L1_writemiss']+=1
            if (len(L1[L1_set_value])<L1_ASSOC):
                L1[L1_set_value].append(L1_tag_value)
                if (REPLACEMENT_POLICY==0):
                    if len(LRU_L1[L1_set_value]) != 0:
                        LRU_L1[L1_set_value][L1_tag_value]=max(LRU_L1[L1_set_value].values())+1
                    else:
                        LRU_L1[L1_set_value][L1_tag_value]=0

                elif (REPLACEMENT_POLICY==1):
                    if len(FIFO_L1[L1_set_value]) != 0:
                        FIFO_L1[L1_set_value][L1_tag_value]=max(FIFO_L1[L1_set_value].values())+1
                    else:
                        FIFO_L1[L1_set_value][L1_tag_value]=0
                L1_dirty_dict[L1_set_value][L1_tag_value]='D'

            else:
                if (REPLACEMENT_POLICY==0):
                    LRU_L1[L1_set_value][L1_tag_value]=max(LRU_L1[L1_set_value].values())+1
                    victim_tag = LRU_Counter_L1_Create(L1_set_value)
                    for i in range(len(L1[L1_set_value])):
                        if L1[L1_set_value][i] == victim_tag:
                            L1[L1_set_value][i] = L1_tag_value
                            break
                    del LRU_L1[L1_set_value][victim_tag]
                    if L1_dirty_dict[L1_set_value][victim_tag]=='D':
                        PARAMETERS_OF_L1['L1_writebacks']+=1
                        if (L2_SIZE!=0 and L2_ASSOC!=0):
                            L2_victim_address = convert_victim_tag_to_L1_indices(L1_set_value, victim_tag)
                            Handle_L2_Cache_Access(L2_victim_address[0], L2_victim_address[1],'w')
                    del L1_dirty_dict[L1_set_value][victim_tag]
                    L1_dirty_dict[L1_set_value][L1_tag_value] = "D"

                if (REPLACEMENT_POLICY==1):
                    FIFO_L1[L1_set_value][L1_tag_value]=max(FIFO_L1[L1_set_value].values())+1
                    victim_tag = FIFO_Counter_L1_create(L1_set_value)
                    for i in range(len(L1[L1_set_value])):
                        if L1[L1_set_value][i] == victim_tag:
                            L1[L1_set_value][i] = L1_tag_value
                            break
                    del FIFO_L1[L1_set_value][victim_tag]
                    if L1_dirty_dict[L1_set_value][victim_tag]=='D':
                        PARAMETERS_OF_L1['L1_writebacks']+=1
                        if (L2_SIZE!=0 and L2_ASSOC!=0):
                            L2_victim_address = convert_victim_tag_to_L1_indices(L1_set_value, victim_tag)
                            Handle_L2_Cache_Access(L2_victim_address[0], L2_victim_address[1],'w')
                    del L1_dirty_dict[L1_set_value][victim_tag]
                    L1_dirty_dict[L1_set_value][L1_tag_value] = "D"

            if (L2_SIZE!=0 and L2_ASSOC!=0):
                Handle_L2_Cache_Access(L2_set_value,L2_tag_value,'r')



cache_sim_config =CacheSimulator.CacheSimulatorConfiguration(BLOCKSIZE,L1_SIZE,L1_ASSOC,L2_SIZE,L2_ASSOC,REPLACEMENT_POLICY,INCLUSION_PROPERTY,trace_file)
cache_sim_config .display_configuration()



print('===== L1 contents =====')
for i, values in enumerate(L1.values()):
    if i <= 9:
        text = f"Set     {i}:      "
    elif i <= 99:
        text = f"Set     {i}:     "
    else:
        text = f"Set     {i}:    "

    for value in values:
        text += hex(int(value, 2))[2:]
        if L1_dirty_dict[i][value] == 'D':
            text += ' D  '
        else:
            text += '    '
    print(text)


from enum import Enum

class CacheState(Enum):
    DIRTY = 'D'
    CLEAN = ''

def print_l2_contents(L2, L2_dirty_dict, set_index=0):
    if set_index >= len(L2):
        return

    set_text = f"Set     {set_index}:      "

    for value in L2[set_index]:
        set_text += hex(int(value, 2))[2:]
        set_text += f' {CacheState(L2_dirty_dict[set_index][value]).value}  '

    print(set_text)

    print_l2_contents(L2, L2_dirty_dict, set_index + 1)

def main():
    if L2_SIZE != 0 and L2_ASSOC != 0:
        print('===== L2 contents =====')
        print_l2_contents(L2, L2_dirty_dict)
L1_miss_rate = float((PARAMETERS_OF_L1['L1_readmiss']+PARAMETERS_OF_L1['L1_writemiss'])/(PARAMETERS_OF_L1['L1_reads']+PARAMETERS_OF_L1['L1_writes']))
if (L2_SIZE!=0 and L2_ASSOC!=0):
    L2_miss_rate = float((PARAMETERS_OF_L2['L2_readmiss'])/(PARAMETERS_OF_L2['L2_reads']))
Traffic_number=0
print("===== Simulation results (raw) =====")
print("a. number of L1 reads:        "+str(PARAMETERS_OF_L1['L1_reads']))
print("b. number of L1 read misses:  "+str(PARAMETERS_OF_L1['L1_readmiss']))
print("c. number of L1 writes:       "+str(PARAMETERS_OF_L1['L1_writes']))
print("d. number of L1 write misses: "+str(PARAMETERS_OF_L1['L1_writemiss']))
print("e. L1 miss rate:              {:.6f}".format(L1_miss_rate))
print("f. number of L1 writebacks:   "+str(PARAMETERS_OF_L1['L1_writebacks']))
print("g. number of L2 reads:        "+str(PARAMETERS_OF_L2['L2_reads']))
print("h. number of L2 read misses:  "+str(PARAMETERS_OF_L2['L2_readmiss']))
print("i. number of L2 writes:       "+str(PARAMETERS_OF_L2['L2_writes']))
print("j. number of L2 write misses: "+str(PARAMETERS_OF_L2['L2_writemiss']))
if (L2_SIZE!=0 and L2_ASSOC!=0):
    print("k. L2 miss rate:              {:.6f}".format(L2_miss_rate))
else:
    print("k. L2 miss rate:              "+str(0))
print("l. number of L2 writebacks:   "+str(PARAMETERS_OF_L2['L2_writebacks']))
if PARAMETERS_OF_L2['L2_reads']==0:
    Traffic_number = PARAMETERS_OF_L1['L1_readmiss']+PARAMETERS_OF_L1['L1_writemiss']+PARAMETERS_OF_L1['L1_writebacks']
else:
    Traffic_number = PARAMETERS_OF_L2['L2_readmiss']+PARAMETERS_OF_L2['L2_writemiss']+PARAMETERS_OF_L2['L2_writebacks']+inclusive_bit_value[0]
print("m. total memory traffic:      "+str(Traffic_number))